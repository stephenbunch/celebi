{
  "version": 3,
  "sources": [
    "node_modules/arceus/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "src/_isPlainObject.js",
    "src/_transformObjectOutsideIn.js",
    "src/any.js",
    "src/arrayOf.js",
    "src/boolean.js",
    "src/constant.js",
    "src/date.js",
    "src/fail.js",
    "src/func.js",
    "src/index.js",
    "src/isSchema.js",
    "src/merge.js",
    "src/nullableOf.js",
    "src/number.js",
    "src/object.js",
    "src/oneOf.js",
    "src/parse.js",
    "src/pass.js",
    "src/shape.js",
    "src/string.js",
    "src/struct.js",
    "src/transformObject.js",
    "src/vm.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "import isSchema from './isSchema';\n\nexport default function( value ) {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    !Array.isArray( value ) &&\n    !isSchema( value )\n  );\n};\n",
    "import isPlainObject from './_isPlainObject';\n\n/**\n * Transforms an object from the outside in. Nodes of objects passed to the\n * replacer function have not been transformed. The object is transformed first,\n * and if the result is a plain object, its nodes are also transformed.\n */\nexport default function transformObjectOutsideIn( object, replace ) {\n  object = replace( object );\n  if ( isPlainObject( object ) ) {\n    return Object.keys( object ).reduce( ( result, key ) => {\n      return {\n        ...result,\n        [ key ]: transformObjectOutsideIn( object[ key ], replace )\n      }\n    }, {} );\n  } else {\n    return object;\n  }\n};\n",
    "import fail from './fail';\nimport merge from './merge';\nimport pass from './pass';\n\nexport default {\n  attributes: {\n    type: 'any'\n  },\n\n  label( name ) {\n    return this.extend({\n      attributes: {\n        label: name\n      }\n    });\n  },\n\n  cast( value, options ) {\n    if ( value === undefined ) {\n      return null;\n    } else {\n      return value;\n    }\n  },\n\n  attempt( value, options ) {\n    var result = this.validate( value, options );\n    if ( result.error ) {\n      throw result.error;\n    } else {\n      return result.value;\n    }\n  },\n\n  validate( value, options ) {\n    return { error: null, value };\n  },\n\n  path( selector ) {\n    return this;\n  },\n\n  extend( spec ) {\n    return merge( {}, this, spec );\n  },\n\n  transform( transform ) {\n    return this;\n  },\n\n  valid( values ) {\n    return this.extend({\n      validate( value ) {\n        if ( values.indexOf( value ) === -1 ) {\n          return fail( this, 'is invalid' );\n        } else {\n          return pass( value );\n        }\n      }\n    });\n  },\n\n  default( defaultValue ) {\n    var parent = this;\n    return this.extend({\n      cast( value, options ) {\n        if ( value === null || value === undefined ) {\n          return parent.cast.call( this, defaultValue, options );\n        } else {\n          return parent.cast.call( this, value, options );\n        }\n      },\n      validate( value, options ) {\n        if ( value === null || value === undefined ) {\n          return parent.validate.call( this, defaultValue, options );\n        } else {\n          return parent.validate.call( this, value, options );\n        }\n      }\n    })\n  },\n\n  optional() {\n    var parent = this;\n    return this.extend({\n      cast( value, options ) {\n        if ( value === undefined ) {\n          return undefined;\n        } else {\n          return parent.cast.call( this, value, options );\n        }\n      },\n      validate( value, options ) {\n        if ( value === undefined ) {\n          return pass( undefined );\n        } else {\n          return parent.validate.call( this, value, options );\n        }\n      }\n    });\n  }\n};\n",
    "import any from './any';\nimport parse from './parse';\nimport pass from './pass';\nimport fail from './fail';\n\nexport default function arrayOf( schema ) {\n  schema = parse( schema );\n  return any.extend({\n    attributes: {\n      type: 'array',\n      schema: schema\n    },\n\n    cast( value, options ) {\n      if ( Array.isArray( value ) ) {\n        return value.map( x => schema.cast( x, options ) );\n      } else {\n        return [];\n      }\n    },\n\n    path( selector ) {\n      return schema.path( selector );\n    },\n\n    validate( value, options = {} ) {\n      if ( !Array.isArray( value ) ) {\n        return fail( this, 'must be an array' );\n      } else {\n        let retval = [];\n        let errors = [];\n        for ( let i = 0; i < value.length; i++ ) {\n          let item = value[ i ];\n          let result = schema.label( schema.attributes.label || `item ${ i }`).validate( item, options );\n          if ( result.error ) {\n            errors.push({\n              key: i,\n              message: result.error.message\n            });\n            if ( options.abortEarly ) {\n              break;\n            }\n          } else {\n            retval.push( result.value );\n          }\n        }\n        if ( errors.length > 0 ) {\n          return fail( this, errors );\n        } else {\n          return pass( retval );\n        }\n      }\n    },\n\n    transform( transform ) {\n      return arrayOf( transform( schema ) );\n    },\n\n    length( length ) {\n      var parent = this;\n      return this.extend({\n        cast( value, options ) {\n          return parent.cast( value, options ).slice( 0, 2 );\n        },\n\n        validate( value, options ) {\n          var result = parent.validate( value, options );\n          if ( result.error ) {\n            return result;\n          } else {\n            result.value = result.value.slice( 0, 2 );\n            return result;\n          }\n        },\n\n        transform( transform ) {\n          return parent.transform( transform ).length( length );\n        }\n      })\n    }\n  });\n};\n",
    "import any from './any';\nimport pass from './pass';\nimport fail from './fail';\n\nexport default any.extend({\n  attributes: {\n    type: 'boolean'\n  },\n\n  cast( value ) {\n    if ( value === 'true' ) {\n      value = true;\n    } else if ( value === 'false' ) {\n      value = false;\n    } else {\n      value = !!value;\n    }\n    return value;\n  },\n\n  validate( value ) {\n    if ( value === 'true' ) {\n      value = true;\n    } else if ( value === 'false' ) {\n      value = false;\n    }\n    if ( typeof value !== 'boolean' ) {\n      return fail( this, 'must be a boolean' );\n    }\n    return pass( value );\n  }\n});\n",
    "import any from './any';\n\nexport default function( value ) {\n  return any.extend({\n    cast() {\n      return value;\n    },\n\n    validate() {\n      return {\n        result: value,\n        error: null\n      };\n    }\n  })\n};\n",
    "import any from './any';\nimport fail from './fail';\nimport pass from './pass';\n\nexport default any.extend({\n  cast( value ) {\n    if ( value instanceof Date ) {\n      return value;\n    } else {\n      return new Date( value || null );\n    }\n  },\n\n  validate( value ) {\n    if ( !( value instanceof Date ) ) {\n      value = new Date( value );\n    }\n    if ( isNaN( value ) ) {\n      return fail( this, 'must be a valid date' );\n    } else {\n      return pass( value );\n    }\n  }\n});\n",
    "import isSchema from './isSchema';\n\nexport default function( schema, reason ) {\n  if ( !isSchema( schema ) ) {\n    throw new Error( 'Expected first argument to be a schema.' );\n  }\n  var error = new Error();\n  error.name = 'ValidationError';\n  if ( typeof reason === 'string' ) {\n    error.message = `\"${ schema.attributes.label || 'value' }\" ${ reason }`;\n  } else if ( Array.isArray( reason ) ) {\n    error.message = `\"${ schema.attributes.label || 'value' }\" fails because [${ reason[0].message }]`;\n    error.details = reason;\n  } else {\n    throw new Error( 'Expected failure reason to be a string, error, or an array.' );\n  }\n  return {\n    error,\n    value: null\n  };\n};\n",
    "import any from './any';\nimport fail from './fail';\nimport pass from './pass';\n\nexport default any.extend({\n  attributes: {\n    type: 'function'\n  },\n\n  cast( value ) {\n    if ( typeof value === 'function' ) {\n      return value;\n    } else {\n      return () => {};\n    }\n  },\n\n  validate( value ) {\n    if ( typeof value !== 'function' ) {\n      return fail( this, 'must be a function' );\n    } else {\n      return pass( value );\n    }\n  }\n});\n",
    "export any from './any';\nexport arrayOf from './arrayOf';\nexport boolean from './boolean';\nexport constant from './constant';\nexport date from './date';\nexport fail from './fail';\nexport func from './func';\nexport isSchema from './isSchema';\nexport nullableOf from './nullableOf';\nexport number from './number';\nexport object from './object';\nexport oneOf from './oneOf';\nexport parse from './parse';\nexport pass from './pass';\nexport shape from './shape';\nexport string from './string';\nexport struct from './struct';\nexport transformObject from './transformObject';\nexport vm from './vm';\n",
    "export default function( value ) {\n  return (\n    value &&\n    typeof value === 'object' &&\n    typeof value.cast === 'function'\n  );\n};\n",
    "import isPlainObject from './_isPlainObject';\n\nexport default function merge( object, ...sources ) {\n  for ( let source of sources ) {\n    for ( let key in source ) {\n      if ( source[ key ] === undefined ) {\n        delete object[ key ];\n      } else if (\n        isPlainObject( source[ key ] ) &&\n        isPlainObject( object[ key ] )\n      ) {\n        object[ key ] = merge( {}, object[ key ], source[ key ] );\n      } else {\n        object[ key ] = source[ key ];\n      }\n    }\n  }\n  return object;\n};\n",
    "import any from './any';\nimport parse from './parse';\nimport pass from './pass';\n\nexport default function nullableOf( schema ) {\n  schema = parse( schema );\n  return any.extend({\n    attributes: {\n      type: 'nullable',\n      schema: schema\n    },\n\n    cast( value, options ) {\n      if ( value === undefined || value === null ) {\n        return null;\n      } else {\n        return schema.cast( value, options );\n      }\n    },\n\n    validate( value, options ) {\n      if ( value === undefined || value === null ) {\n        return pass( null );\n      } else {\n        return schema.validate( value, options );\n      }\n    },\n\n    path( selector ) {\n      return schema.path( selector );\n    },\n\n    transform( transform ) {\n      return nullableOf( transform( schema ) );\n    }\n  });\n};\n",
    "import any from './any';\nimport pass from './pass';\nimport fail from './fail';\n\nexport default any.extend({\n  attributes: {\n    type: 'number'\n  },\n\n  cast( value ) {\n    value = Number( value );\n    if ( isNaN( value ) ) {\n      return 0;\n    }\n    return value;\n  },\n\n  validate( value ) {\n    if ( isNaN( value ) ) {\n      return fail( this, 'must be a number' );\n    }\n    return pass( Number( value ) );\n  }\n});\n",
    "import any from './any';\nimport fail from './fail';\nimport pass from './pass';\n\nexport default any.extend({\n  attributes: {\n    title: 'object'\n  },\n\n  cast( value ) {\n    if ( !value || typeof value !== 'object' || Array.isArray( value ) ) {\n      return {};\n    } else {\n      return value;\n    }\n  },\n\n  validate( value ) {\n    if ( !value || typeof value !== 'object' || Array.isArray( value ) ) {\n      return fail( this, 'must be an object' );\n    } else {\n      return pass( value );\n    }\n  }\n});\n",
    "import any from './any';\nimport fail from './fail';\nimport parse from './parse';\n\nexport default function oneOf( discriminator, schemas ) {\n  for ( let key in schemas ) {\n    schemas[ key ] = parse( schemas[ key ] );\n  }\n  return any.extend({\n    attributes: {\n      type: 'discriminator',\n      schemas\n    },\n\n    path( selector ) {\n      var [ discriminator, ...rest ] = selector.split( '.' );\n      if ( !schemas[ discriminator ] ) {\n        let keys = Object.keys( this.attributes.schemas );\n        throw new Error( `Discriminator at \"${ selector }\" must be one of ${ keys.join( ', ' ) }` );\n      }\n      return schemas[ discriminator ].path( rest.join( '.' ) );\n    },\n\n    cast( value, options ) {\n      if (\n        typeof value === 'object' && value !== null &&\n        schemas[ value[ discriminator ] ]\n      ) {\n        return schemas[ value[ discriminator ] ].cast( value );\n      }\n    },\n\n    validate( value, options ) {\n      if ( typeof value !== 'object' || value === null ) {\n        return fail( this, 'must be an object' );\n      }\n      if ( !schemas[ value[ discriminator ] ] ) {\n        let keys = Object.keys( this.attributes.schemas );\n        return fail( this, `${ discriminator } must be one of ${ keys.join( ', ' ) }` );\n      }\n      return schemas[ value[ discriminator ] ].cast( value, options );\n    },\n\n    transform( transform ) {\n      var schemas = {};\n      for ( key in this.attributes.schemas ) {\n        schemas[ key ] = transform( this.attributes.schemas[ key ] );\n      }\n      return oneOf( discriminator, schemas );\n    }\n  });\n};\n",
    "import any from './any';\nimport arrayOf from './arrayOf';\nimport boolean from './boolean';\nimport date from './date';\nimport func from './func';\nimport isSchema from './isSchema';\nimport number from './number';\nimport object from './object';\nimport shape from './shape';\nimport string from './string';\n\nexport default function parse( value ) {\n  if ( typeof value === 'function' ) {\n    if ( value === String ) {\n      value = string;\n    } else if ( value === Boolean ) {\n      value = boolean;\n    } else if ( value === Number ) {\n      value = number;\n    } else if ( value === Object ) {\n      value = object;\n    } else if ( value === Date ) {\n      value = date;\n    } else if ( value === Function ) {\n      value = func;\n    } else {\n      value = any.extend({\n        cast: value\n      });\n    }\n  } else if ( Array.isArray( value ) ) {\n    value = arrayOf( parse( value[0] || any ) );\n  } else if ( !isSchema( value ) ) {\n    if ( typeof value === 'object' && value !== null ) {\n      value = shape( value );\n    } else {\n      throw new Error( `Cannot parse schema value '${ value }' (${ typeof value }).` );\n    }\n  }\n  return value;\n};\n",
    "export default function( value ) {\n  return { error: null, value };\n};\n",
    "import any from './any';\nimport fail from './fail';\nimport pass from './pass';\nimport parse from './parse';\nimport transformObject from './transformObject';\nimport isSchema from './isSchema';\nimport isPlainObject from './_isPlainObject';\nimport merge from './merge';\nimport transformObjectOutsideIn from './_transformObjectOutsideIn';\n\nexport default function shape( spec ) {\n  if ( isSchema( spec ) ) {\n    if ( spec.attributes.type === 'shape' ) {\n      return shape( spec.attributes.keys );\n    } else {\n      throw new Error( 'Argument must be a plain object or a shape schema.' );\n    }\n  }\n  return transformObject( spec, function( spec ) {\n    for ( let key in spec ) {\n      spec[ key ] = parse( spec[ key ] );\n    }\n    return any.extend({\n      attributes: {\n        type: 'shape',\n        keys: spec\n      },\n\n      cast( value, options ) {\n        var retval = {};\n        if ( !isPlainObject( value ) ) {\n          value = {};\n        }\n        for ( let key in this.attributes.keys ) {\n          let val = this.attributes.keys[ key ].cast( value[ key ] );\n          if ( val !== undefined ) {\n            retval[ key ] = val;\n          }\n        }\n        return retval;\n      },\n\n      validate( value, options = {} ) {\n        if ( value === null || typeof value !== 'object' ) {\n          return fail( this, 'must be an object' );\n        }\n        var errors = [];\n        var retval = {};\n        for ( let key in this.attributes.keys ) {\n          let label = this.attributes.keys[ key ].attributes.label || key;\n          let result = this.attributes.keys[ key ].label( label ).validate( value[ key ], options );\n          if ( result.error ) {\n            errors.push({\n              key: key,\n              message: result.error.message\n            });\n            if ( options.abortEarly ) {\n              break;\n            }\n          } else {\n            if ( result.value !== undefined ) {\n              retval[ key ] = result.value;\n            }\n          }\n        }\n        if ( errors.length > 0 ) {\n          return fail( this, errors );\n        }\n        return pass( retval );\n      },\n\n      path( selector ) {\n        var [ top, ...rest ] = selector.split( '.' );\n        for ( let key in this.attributes.keys ) {\n          if ( key === top ) {\n            return this.attributes.keys[ key ].path( rest.join( '.' ) );\n          }\n        }\n        throw new Error( `Path \"${ selector }\" is invalid.` );\n      },\n\n      without( ...keys ) {\n        var spec = {};\n        for ( let key in this.attributes.keys ) {\n          if ( keys.indexOf( key ) === -1 ) {\n            spec[ key ] = this.attributes.keys[ key ];\n          } else {\n            // delete the key\n            spec[ key ] = undefined;\n          }\n        }\n        return this.extend({\n          attributes: {\n            keys: spec\n          }\n        });\n      },\n\n      pluck( ...keys ) {\n        var spec = {};\n        for ( let key in this.attributes.keys ) {\n          if ( keys.indexOf( key ) > -1 ) {\n            spec[ key ] = this.attributes.keys[ key ];\n          } else {\n            // delete the key\n            spec[ key ] = undefined;\n          }\n        }\n        return this.extend({\n          attributes: {\n            keys: spec\n          }\n        });\n      },\n\n      merge( spec ) {\n        spec = transformObjectOutsideIn(\n          shape( spec ),\n          x => x.attributes.type === 'shape' ? x.attributes.keys : x\n        );\n        var self = transformObjectOutsideIn(\n          this,\n          x => x.attributes.type === 'shape' ? x.attributes.keys : x\n        );\n        return shape( merge( self, spec ) );\n      },\n\n      transform( transform ) {\n        var spec = {};\n        for ( let key in this.attributes.keys ) {\n          spec[ key ] = transform( this.attributes.keys[ key ].transform( transform ) );\n        }\n        return this.extend({\n          attributes: {\n            keys: spec\n          }\n        });\n      },\n\n      unknown() {\n        var parent = this.transform( schema => {\n          if ( schema.attributes.type === 'shape' ) {\n            return schema.unknown();\n          } else {\n            return schema;\n          }\n        });\n        return parent.extend({\n          attributes: {\n            unknown: true\n          },\n          cast( value, options ) {\n            var retval = parent.cast.call( this, value, options );\n            for ( let key in value ) {\n              if ( !this.attributes.keys[ key ] ) {\n                if ( value[ key ] !== undefined ) {\n                  retval[ key ] = value[ key ];\n                }\n              }\n            }\n            return retval;\n          },\n\n          validate( value, options ) {\n            var result = parent.validate.call( this, value, options );\n            if ( result.value ) {\n              for ( let key in value ) {\n                if ( !this.attributes.keys[ key ] ) {\n                  if ( value[ key ] !== undefined ) {\n                    result.value[ key ] = value[ key ];\n                  }\n                }\n              }\n            }\n            return result;\n          }\n        });\n      }\n    });\n  });\n};\n",
    "import any from './any';\nimport fail from './fail';\nimport pass from './pass';\n\n// http://stackoverflow.com/a/46181\nconst email = /^(([^<>()[\\]\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n\nexport default any.extend({\n  attributes: {\n    type: 'string'\n  },\n\n  cast( value ) {\n    return String( value || '' );\n  },\n\n  validate( value ) {\n    if ( !value || typeof value !== 'string' ) {\n      return fail( this, 'must be a non-empty string' );\n    }\n    return pass( value );\n  },\n\n  email() {\n    var parent = this;\n    return this.extend({\n      validate( value, options ) {\n        if ( !email.test( value ) ) {\n          return fail( this, 'must be an email' );\n        } else {\n          return parent.validate.call( this, value, options );\n        }\n      }\n    });\n  },\n\n  lowerCase() {\n    var parent = this;\n    return this.extend({\n      cast( value ) {\n        return parent.cast.call( this, value ).toLowerCase();\n      },\n      validate( value, options ) {\n        var result = parent.validate.call( this, value, options );\n        if ( result.value ) {\n          result.value = result.value.toLowerCase();\n        }\n        return result;\n      }\n    })\n  },\n\n  upperCase() {\n    var parent = this;\n    return this.extend({\n      cast( value ) {\n        return parent.cast.call( this, value ).toUpperCase();\n      },\n      validate( value, options ) {\n        var result = parent.validate.call( this, value, options );\n        if ( result.value ) {\n          result.value = result.value.toUpperCase();\n        }\n        return result;\n      }\n    })\n  },\n\n  trim() {\n    var parent = this;\n    return this.extend({\n      cast( value, options ) {\n        return parent.cast.call( this, value, options ).trim();\n      },\n      validate( value, options ) {\n        var result = parent.validate.call( this, value, options );\n        if ( result.value ) {\n          result.value = result.value.trim();\n        }\n        return result;\n      }\n    })\n  },\n\n  default( defaultValue ) {\n    var parent = this;\n    return this.extend({\n      cast( value, options ) {\n        if ( !value ) {\n          return parent.cast.call( this, defaultValue, options );\n        } else {\n          return parent.cast.call( this, value, options );\n        }\n      },\n\n      validate( value, options ) {\n        if ( !value ) {\n          return parent.validate.call( this, defaultValue, options );\n        } else {\n          return parent.validate.call( this, value, options );\n        }\n      }\n    });\n  },\n\n  optional() {\n    var parent = this;\n    return this.extend({\n      attributes: {\n        optional: true\n      },\n\n      cast( value, options ) {\n        if ( !value ) {\n          return;\n        } else {\n          return parent.cast.call( this, value, options );\n        }\n      },\n\n      validate( value, options ) {\n        if ( !value ) {\n          return pass();\n        } else {\n          return parent.validate.call( this, value, options );\n        }\n      }\n    });\n  }\n});\n",
    "import shape from './shape';\n\nexport default function( spec ) {\n  return shape( spec ).extend({\n    attributes: {\n      type: 'struct'\n    }\n  });\n};\n",
    "import isPlainObject from './_isPlainObject';\n\n/**\n * Transforms an object from the inside out. The root object is assumed to be a\n * plain object, and its nodes are transformed before the object is passed to\n * the replacer function have already been transformed.\n */\nexport default function transformObject( object, replace ) {\n  if ( !isPlainObject( object ) ) {\n    throw new Error( 'Object must be a plain object.' );\n  }\n  return _transformObject( object, replace );\n};\n\nfunction _transformObject( object, replace ) {\n  return replace(\n    Object.keys( object ).reduce( ( result, key ) => {\n      if ( isPlainObject( object[ key ] ) ) {\n        return {\n          ...result,\n          [ key ]: _transformObject( object[ key ], replace )\n        };\n      } else {\n        return {\n          ...result,\n          [ key ]: object[ key ]\n        };\n      }\n    }, {} )\n  );\n}\n",
    "import isSchema from './isSchema';\nimport shape from './shape';\nimport transformObject from './transformObject';\n\nexport default function vm( schema ) {\n  if ( isSchema( schema ) ) {\n    if ( schema.attributes.type !== 'shape' ) {\n      throw new Error( 'Schema must be a shape.' );\n    }\n  } else {\n    schema = shape( schema );\n  }\n  schema = schema.transform( function transform( node ) {\n    if ( node.attributes.type === 'shape' ) {\n      return vm( node );\n    } else {\n      return node;\n    }\n  });\n  return schema.extend({\n    attributes: {\n      type: 'vm',\n      keys: schema.attributes.keys\n    },\n\n    cast( source, options ) {\n      if ( source === null || typeof source !== 'object' ) {\n        source = {};\n      }\n      var model = {};\n      for ( let key in this.attributes.keys ) {\n        let _value = this.attributes.keys[ key ].cast( source[ key ] );\n        Object.defineProperty( model, key, {\n          enumerable: true,\n          configurable: true,\n          get: () => _value,\n          set: value => {\n            _value = this.attributes.keys[ key ].cast( value );\n          }\n        });\n      }\n      return model;\n    }\n  });\n};\n"
  ]
}